using JuMP

import Ipopt

 

rosenbrock(x...) = (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2

 

function ∇rosenbrock(g::AbstractVector, x...)

    g[1] = 400 * x[1]^3 - 400 * x[1] * x[2] + 2 * x[1] - 2

    g[2] = 200 * (x[2] - x[1]^2)

    return

end

 

function ∇²rosenbrock(H::AbstractMatrix, x...)

    H[1, 1] = 1200 * x[1]^2 - 400 * x[2] + 2

    # H[1, 2] = -400 * x[1] <-- not needed because Hessian is symmetric

    H[2, 1] = -400 * x[1]

    H[2, 2] = 200.0

    return

end

 

model = Model(Ipopt.Optimizer)

x = @variable(model, x[1:2])

register(model, :rosenbrock, 2, rosenbrock, ∇rosenbrock, ∇²rosenbrock)

@NLobjective(model, Min, rosenbrock(x[1], x[2]))

optimize!(model)

solution_summary(model; verbose = true)

println("---------")

println("---------")

println("---------")

# Get the optimal values

x_opt = value.(x)

 

# # Update the initial value of x

# for i in 1:2

#     set_start_value(x[i], x_opt[i])

# end

# Fix x 
fix.(x, x_opt; force=true)

# resolve the problem, now it only takes 1 iter

optimize!(model)


solution_summary(model; verbose = true)